{
  "language": "Solidity",
  "sources": {
    "contracts/AngleRouter01.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./interfaces/IFeeDistributor.sol\";\nimport \"./interfaces/ILiquidityGauge.sol\";\nimport \"./interfaces/ISanToken.sol\";\nimport \"./interfaces/IStableMaster.sol\";\nimport \"./interfaces/IStableMasterFront.sol\";\nimport \"./interfaces/IVeANGLE.sol\";\nimport \"./interfaces/external/IWETH9.sol\";\nimport \"./interfaces/external/uniswap/IUniswapRouter.sol\";\nimport \"./interfaces/IVaultManager.sol\";\nimport \"./interfaces/external/lido/ISteth.sol\";\nimport \"./interfaces/external/lido/IWStETH.sol\";\n\n/// @title Angle Router\n/// @author Angle Core Team\n/// @notice The `AngleRouter` contract facilitates interactions for users with the protocol. It was built to reduce the number\n/// of approvals required to users and the number of transactions needed to perform some complex actions: like deposit and stake\n/// in just one transaction\n/// @dev Interfaces were designed for both advanced users which know the addresses of the protocol's contract, but most of the time\n/// users which only know addresses of the stablecoins and collateral types of the protocol can perform the actions they want without\n/// needing to understand what's happening under the hood\ncontract AngleRouter is Initializable, ReentrancyGuardUpgradeable {\n    using SafeERC20 for IERC20;\n    /// @notice Base used for params\n    uint256 public constant BASE_PARAMS = 10**9;\n\n    /// @notice Base used for params\n    uint256 private constant _MAX_TOKENS = 10;\n    // @notice Wrapped ETH contract\n    IWETH9 public constant WETH9 = IWETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    // @notice ANGLE contract\n    IERC20 public constant ANGLE = IERC20(0x31429d1856aD1377A8A0079410B297e1a9e214c2);\n    // @notice veANGLE contract\n    IVeANGLE public constant VEANGLE = IVeANGLE(0x0C462Dbb9EC8cD1630f1728B2CFD2769d09f0dd5);\n\n    // =========================== Structs and Enums ===============================\n\n    /// @notice Action types\n    enum ActionType {\n        claimRewards,\n        claimWeeklyInterest,\n        gaugeDeposit,\n        withdraw,\n        mint,\n        deposit,\n        openPerpetual,\n        addToPerpetual,\n        veANGLEDeposit,\n        borrower\n    }\n\n    /// @notice All possible swaps\n    enum SwapType {\n        UniswapV3,\n        oneINCH,\n        WrapStETH,\n        None\n    }\n\n    /// @notice Params for swaps\n    /// @param inToken Token to swap\n    /// @param collateral Token to swap for\n    /// @param amountIn Amount of token to sell\n    /// @param minAmountOut Minimum amount of collateral to receive for the swap to not revert\n    /// @param args Either the path for Uniswap or the payload for 1Inch\n    /// @param swapType Which swap route to take\n    struct ParamsSwapType {\n        IERC20 inToken;\n        address collateral;\n        uint256 amountIn;\n        uint256 minAmountOut;\n        bytes args;\n        SwapType swapType;\n    }\n\n    /// @notice Params for direct collateral transfer\n    /// @param inToken Token to transfer\n    /// @param amountIn Amount of token transfer\n    struct TransferType {\n        IERC20 inToken;\n        uint256 amountIn;\n    }\n\n    /// @notice References to the contracts associated to a collateral for a stablecoin\n    struct Pairs {\n        IPoolManager poolManager;\n        IPerpetualManagerFrontWithClaim perpetualManager;\n        ISanToken sanToken;\n        ILiquidityGauge gauge;\n    }\n\n    /// @notice Data needed to get permits\n    struct PermitType {\n        address token;\n        address owner;\n        uint256 value;\n        uint256 deadline;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    // =============================== Events ======================================\n\n    event AdminChanged(address indexed admin, bool setGovernor);\n    event StablecoinAdded(address indexed stableMaster);\n    event StablecoinRemoved(address indexed stableMaster);\n    event CollateralToggled(address indexed stableMaster, address indexed poolManager, address indexed liquidityGauge);\n    event SanTokenLiquidityGaugeUpdated(address indexed sanToken, address indexed newLiquidityGauge);\n    event Recovered(address indexed tokenAddress, address indexed to, uint256 amount);\n\n    // =============================== Mappings ====================================\n\n    /// @notice Maps an agToken to its counterpart `StableMaster`\n    mapping(IERC20 => IStableMasterFront) public mapStableMasters;\n    /// @notice Maps a `StableMaster` to a mapping of collateral token to its counterpart `PoolManager`\n    mapping(IStableMasterFront => mapping(IERC20 => Pairs)) public mapPoolManagers;\n    /// @notice Whether the token was already approved on Uniswap router\n    mapping(IERC20 => bool) public uniAllowedToken;\n    /// @notice Whether the token was already approved on 1Inch\n    mapping(IERC20 => bool) public oneInchAllowedToken;\n\n    // =============================== References ==================================\n\n    /// @notice Governor address\n    address public governor;\n    /// @notice Guardian address\n    address public guardian;\n    /// @notice Address of the router used for swaps\n    IUniswapV3Router public uniswapV3Router;\n    /// @notice Address of 1Inch router used for swaps\n    address public oneInch;\n\n    uint256[50] private __gap;\n\n    struct PermitVaultManagerType {\n        address vaultManager;\n        address owner;\n        bool approved;\n        uint256 deadline;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    /// @notice StETH contract\n    IStETH public constant STETH = IStETH(0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84);\n    /// @notice Wrapped StETH contract\n    IWStETH public constant WSTETH = IWStETH(0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0);\n\n    // ============================= Error Messages ================================\n\n    error AlreadyAdded();\n    error IncompatibleLengths();\n    error InvalidAddress();\n    error InvalidCall();\n    error InvalidConditions();\n    error InvalidReturnMessage();\n    error InvalidToken();\n    error NotApprovedOrOwner();\n    error NotGovernorOrGuardian();\n    error TooSmallAmountOut();\n    error ZeroAddress();\n\n    constructor() initializer {}\n\n    // Removed the `initialize` function in this implementation since it has already been called and can not be called again\n    // You can check it for context at the end of this contract\n\n    // ============================== Modifiers ====================================\n\n    /// @notice Checks to see if it is the `governor` or `guardian` calling this contract\n    /// @dev There is no Access Control here, because it can be handled cheaply through this modifier\n    /// @dev In this contract, the `governor` and the `guardian` address have exactly similar rights\n    modifier onlyGovernorOrGuardian() {\n        if (msg.sender != governor && msg.sender != guardian) revert NotGovernorOrGuardian();\n        _;\n    }\n\n    // =========================== Governance utilities ============================\n\n    /// @notice Changes the guardian or the governor address\n    /// @param admin New guardian or guardian address\n    /// @param setGovernor Whether to set Governor if true, or Guardian if false\n    /// @dev There can only be one guardian and one governor address in the router\n    /// and both need to be different\n    function setGovernorOrGuardian(address admin, bool setGovernor) external onlyGovernorOrGuardian {\n        if (admin == address(0)) revert ZeroAddress();\n        if (guardian == admin || governor == admin) revert InvalidAddress();\n        if (setGovernor) governor = admin;\n        else guardian = admin;\n        emit AdminChanged(admin, setGovernor);\n    }\n\n    /// @notice Adds a new `StableMaster`\n    /// @param stablecoin Address of the new stablecoin\n    /// @param stableMaster Address of the new `StableMaster`\n    function addStableMaster(IERC20 stablecoin, IStableMasterFront stableMaster) external onlyGovernorOrGuardian {\n        // No need to check if the `stableMaster` address is a zero address as otherwise the call to `stableMaster.agToken()`\n        // would revert\n        if (address(stablecoin) == address(0)) revert ZeroAddress();\n        if (address(mapStableMasters[stablecoin]) != address(0)) revert AlreadyAdded();\n        if (stableMaster.agToken() != address(stablecoin)) revert InvalidToken();\n        mapStableMasters[stablecoin] = stableMaster;\n        emit StablecoinAdded(address(stableMaster));\n    }\n\n    /// @notice Removes a `StableMaster`\n    /// @param stablecoin Address of the associated stablecoin\n    /// @dev Before calling this function, governor or guardian should remove first all pairs\n    /// from the `mapPoolManagers[stableMaster]`. It is assumed that the governor or guardian calling this function\n    /// will act correctly here, it indeed avoids storing a list of all pairs for each `StableMaster`\n    function removeStableMaster(IERC20 stablecoin) external onlyGovernorOrGuardian {\n        IStableMasterFront stableMaster = mapStableMasters[stablecoin];\n        delete mapStableMasters[stablecoin];\n        emit StablecoinRemoved(address(stableMaster));\n    }\n\n    /// @notice Adds new collateral types to specific stablecoins\n    /// @param stablecoins Addresses of the stablecoins associated to the `StableMaster` of interest\n    /// @param poolManagers Addresses of the `PoolManager` contracts associated to the pair (stablecoin,collateral)\n    /// @param liquidityGauges Addresses of liquidity gauges contract associated to sanToken\n    function addPairs(\n        IERC20[] calldata stablecoins,\n        IPoolManager[] calldata poolManagers,\n        ILiquidityGauge[] calldata liquidityGauges\n    ) external onlyGovernorOrGuardian {\n        if (poolManagers.length != stablecoins.length || liquidityGauges.length != stablecoins.length)\n            revert IncompatibleLengths();\n        for (uint256 i = 0; i < stablecoins.length; i++) {\n            IStableMasterFront stableMaster = mapStableMasters[stablecoins[i]];\n            _addPair(stableMaster, poolManagers[i], liquidityGauges[i]);\n        }\n    }\n\n    /// @notice Removes collateral types from specific `StableMaster` contracts using the address\n    /// of the associated stablecoins\n    /// @param stablecoins Addresses of the stablecoins\n    /// @param collaterals Addresses of the collaterals\n    /// @param stableMasters List of the associated `StableMaster` contracts\n    /// @dev In the lists, if a `stableMaster` address is null in `stableMasters` then this means that the associated\n    /// `stablecoins` address (at the same index) should be non null\n    function removePairs(\n        IERC20[] calldata stablecoins,\n        IERC20[] calldata collaterals,\n        IStableMasterFront[] calldata stableMasters\n    ) external onlyGovernorOrGuardian {\n        if (collaterals.length != stablecoins.length || stableMasters.length != collaterals.length)\n            revert IncompatibleLengths();\n        Pairs memory pairs;\n        IStableMasterFront stableMaster;\n        for (uint256 i = 0; i < stablecoins.length; i++) {\n            if (address(stableMasters[i]) == address(0))\n                // In this case `collaterals[i]` is a collateral address\n                (stableMaster, pairs) = _getInternalContracts(stablecoins[i], collaterals[i]);\n            else {\n                // In this case `collaterals[i]` is a `PoolManager` address\n                stableMaster = stableMasters[i];\n                pairs = mapPoolManagers[stableMaster][collaterals[i]];\n            }\n            delete mapPoolManagers[stableMaster][collaterals[i]];\n            _changeAllowance(collaterals[i], address(stableMaster), 0);\n            _changeAllowance(collaterals[i], address(pairs.perpetualManager), 0);\n            if (address(pairs.gauge) != address(0)) pairs.sanToken.approve(address(pairs.gauge), 0);\n            emit CollateralToggled(address(stableMaster), address(pairs.poolManager), address(pairs.gauge));\n        }\n    }\n\n    /// @notice Sets new `liquidityGauge` contract for the associated sanTokens\n    /// @param stablecoins Addresses of the stablecoins\n    /// @param collaterals Addresses of the collaterals\n    /// @param newLiquidityGauges Addresses of the new liquidity gauges contract\n    /// @dev If `newLiquidityGauge` is null, this means that there is no liquidity gauge for this pair\n    /// @dev This function could be used to simply revoke the approval to a liquidity gauge\n    function setLiquidityGauges(\n        IERC20[] calldata stablecoins,\n        IERC20[] calldata collaterals,\n        ILiquidityGauge[] calldata newLiquidityGauges\n    ) external onlyGovernorOrGuardian {\n        if (collaterals.length != stablecoins.length || newLiquidityGauges.length != stablecoins.length)\n            revert IncompatibleLengths();\n        for (uint256 i = 0; i < stablecoins.length; i++) {\n            IStableMasterFront stableMaster = mapStableMasters[stablecoins[i]];\n            Pairs storage pairs = mapPoolManagers[stableMaster][collaterals[i]];\n            ILiquidityGauge gauge = pairs.gauge;\n            ISanToken sanToken = pairs.sanToken;\n            if (address(stableMaster) == address(0) || address(pairs.poolManager) == address(0)) revert ZeroAddress();\n            pairs.gauge = newLiquidityGauges[i];\n            if (address(gauge) != address(0)) {\n                sanToken.approve(address(gauge), 0);\n            }\n            if (address(newLiquidityGauges[i]) != address(0)) {\n                // Checking compatibility of the staking token: it should be the sanToken\n                if (address(newLiquidityGauges[i].staking_token()) != address(sanToken)) revert InvalidToken();\n                sanToken.approve(address(newLiquidityGauges[i]), type(uint256).max);\n            }\n            emit SanTokenLiquidityGaugeUpdated(address(sanToken), address(newLiquidityGauges[i]));\n        }\n    }\n\n    /// @notice Change allowance for a contract.\n    /// @param tokens Addresses of the tokens to allow\n    /// @param spenders Addresses to allow transfer\n    /// @param amounts Amounts to allow\n    /// @dev Approvals are normally given in the `addGauges` method, in the initializer and in\n    /// the internal functions to process swaps with Uniswap and 1Inch\n    function changeAllowance(\n        IERC20[] calldata tokens,\n        address[] calldata spenders,\n        uint256[] calldata amounts\n    ) external onlyGovernorOrGuardian {\n        if (tokens.length != spenders.length || tokens.length != amounts.length) revert IncompatibleLengths();\n        for (uint256 i = 0; i < tokens.length; i++) {\n            _changeAllowance(tokens[i], spenders[i], amounts[i]);\n        }\n    }\n\n    /// @notice Supports recovering any tokens as the router does not own any other tokens than\n    /// the one mistakenly sent\n    /// @param tokenAddress Address of the token to transfer\n    /// @param to Address to give tokens to\n    /// @param tokenAmount Amount of tokens to transfer\n    /// @dev If tokens are mistakenly sent to this contract, any address can take advantage of the `mixer` function\n    /// below to get the funds back\n    function recoverERC20(\n        address tokenAddress,\n        address to,\n        uint256 tokenAmount\n    ) external onlyGovernorOrGuardian {\n        IERC20(tokenAddress).safeTransfer(to, tokenAmount);\n        emit Recovered(tokenAddress, to, tokenAmount);\n    }\n\n    // =========================== Router Functionalities =========================\n\n    /// @notice Wrapper n°1 built on top of the _claimRewards function\n    /// Allows to claim rewards for multiple gauges and perpetuals at once\n    /// @param gaugeUser Address for which to fetch the rewards from the gauges\n    /// @param liquidityGauges Gauges to claim on\n    /// @param perpetualIDs Perpetual IDs to claim rewards for\n    /// @param stablecoins Stablecoin contracts linked to the perpetualsIDs\n    /// @param collaterals Collateral contracts linked to the perpetualsIDs or `perpetualManager`\n    /// @dev If the caller wants to send the rewards to another account it first needs to\n    /// call `set_rewards_receiver(otherAccount)` on each `liquidityGauge`\n    function claimRewards(\n        address gaugeUser,\n        address[] memory liquidityGauges,\n        uint256[] memory perpetualIDs,\n        address[] memory stablecoins,\n        address[] memory collaterals\n    ) external {\n        _claimRewards(gaugeUser, liquidityGauges, perpetualIDs, false, stablecoins, collaterals);\n    }\n\n    /// @notice Wrapper n°2 (a little more gas efficient than n°1) built on top of the _claimRewards function\n    /// Allows to claim rewards for multiple gauges and perpetuals at once\n    /// @param user Address to which the contract should send the rewards from gauges (not perpetuals)\n    /// @param liquidityGauges Contracts to claim for\n    /// @param perpetualIDs Perpetual IDs to claim rewards for\n    /// @param perpetualManagers `perpetualManager` contracts for every perp to claim\n    /// @dev If the caller wants to send the rewards to another account it first needs to\n    /// call `set_rewards_receiver(otherAccount)` on each `liquidityGauge`\n    function claimRewards(\n        address user,\n        address[] memory liquidityGauges,\n        uint256[] memory perpetualIDs,\n        address[] memory perpetualManagers\n    ) external {\n        _claimRewards(user, liquidityGauges, perpetualIDs, true, new address[](perpetualIDs.length), perpetualManagers);\n    }\n\n    /// @notice Wrapper built on top of the `_mint` method to mint stablecoins\n    /// @param user Address to send the stablecoins to\n    /// @param amount Amount of collateral to use for the mint\n    /// @param minStableAmount Minimum stablecoin minted for the tx not to revert\n    /// @param stablecoin Address of the stablecoin to mint\n    /// @param collateral Collateral to mint from\n    function mint(\n        address user,\n        uint256 amount,\n        uint256 minStableAmount,\n        address stablecoin,\n        address collateral\n    ) external {\n        IERC20(collateral).safeTransferFrom(msg.sender, address(this), amount);\n        _mint(user, amount, minStableAmount, false, stablecoin, collateral, IPoolManager(address(0)));\n    }\n\n    /// @notice Wrapper built on top of the `_burn` method to burn stablecoins\n    /// @param dest Address to send the collateral to\n    /// @param amount Amount of stablecoins to use for the burn\n    /// @param minCollatAmount Minimum collateral amount received for the tx not to revert\n    /// @param stablecoin Address of the stablecoin to mint\n    /// @param collateral Collateral to mint from\n    function burn(\n        address dest,\n        uint256 amount,\n        uint256 minCollatAmount,\n        address stablecoin,\n        address collateral\n    ) external {\n        _burn(dest, amount, minCollatAmount, false, stablecoin, collateral, IPoolManager(address(0)));\n    }\n\n    /// @notice Allows composable calls to different functions within the protocol\n    /// @param paramsPermit Array of params `PermitType` used to do a 1 tx to approve the router on each token (can be done once by\n    /// setting high approved amounts) which supports the `permit` standard. Users willing to interact with the contract\n    /// with tokens that do not support permit should approve the contract for these tokens prior to interacting with it\n    /// @param paramsTransfer Array of params `TransferType` used to transfer tokens to the router\n    /// @param paramsSwap Array of params `ParamsSwapType` used to swap tokens\n    /// @param actions List of actions to be performed by the router (in order of execution): make sure to read for each action the\n    /// associated internal function\n    /// @param data Array of encoded data for each of the actions performed in this mixer. This is where the bytes-encoded parameters\n    /// for a given action are stored\n    /// @dev This function first fills the router balances via transfers and swaps. It then proceeds with each\n    /// action in the order at which they are given\n    /// @dev With this function, users can specify paths to swap tokens to the desired token of their choice. Yet the protocol\n    /// does not verify the payload given and cannot check that the swap performed by users actually gives the desired\n    /// out token: in this case funds will be lost by the user\n    /// @dev For some actions (`mint`, `deposit`, `openPerpetual`, `addToPerpetual`, `withdraw`), users are\n    /// required to give a proportion of the amount of token they have brought to the router within the transaction (through\n    /// a direct transfer or a swap) they want to use for the operation. If you want to use all the USDC you have brought (through an ETH -> USDC)\n    /// swap to mint stablecoins for instance, you should use `BASE_PARAMS` as a proportion.\n    /// @dev The proportion that is specified for an action is a proportion of what is left. If you want to use 50% of your USDC for a `mint`\n    /// and the rest for an `openPerpetual`, proportion used for the `mint` should be 50% (that is `BASE_PARAMS/2`), and proportion\n    /// for the `openPerpetual` should be all that is left that is 100% (= `BASE_PARAMS`).\n    /// @dev For each action here, make sure to read the documentation of the associated internal function to know how to correctly\n    /// specify parameters\n    function mixer(\n        PermitType[] memory paramsPermit,\n        TransferType[] memory paramsTransfer,\n        ParamsSwapType[] memory paramsSwap,\n        ActionType[] memory actions,\n        bytes[] calldata data\n    ) public payable {\n        // Do all the permits once for all: if all tokens have already been approved, there's no need for this step\n        for (uint256 i = 0; i < paramsPermit.length; i++) {\n            IERC20PermitUpgradeable(paramsPermit[i].token).permit(\n                paramsPermit[i].owner,\n                address(this),\n                paramsPermit[i].value,\n                paramsPermit[i].deadline,\n                paramsPermit[i].v,\n                paramsPermit[i].r,\n                paramsPermit[i].s\n            );\n        }\n\n        // Then, do all the transfer to load all needed funds into the router\n        // This function is limited to 10 different assets to be spent on the protocol (agTokens, collaterals, sanTokens)\n        address[_MAX_TOKENS] memory listTokens;\n        uint256[_MAX_TOKENS] memory balanceTokens;\n\n        for (uint256 i = 0; i < paramsTransfer.length; i++) {\n            paramsTransfer[i].inToken.safeTransferFrom(msg.sender, address(this), paramsTransfer[i].amountIn);\n            _addToList(listTokens, balanceTokens, address(paramsTransfer[i].inToken), paramsTransfer[i].amountIn);\n        }\n\n        for (uint256 i = 0; i < paramsSwap.length; i++) {\n            // Caution here: if the args are not set such that end token is the params `paramsSwap[i].collateral`,\n            // then the funds will be lost, and any user could take advantage of it to fetch the funds\n            uint256 amountOut = _transferAndSwap(\n                paramsSwap[i].inToken,\n                paramsSwap[i].amountIn,\n                paramsSwap[i].minAmountOut,\n                paramsSwap[i].swapType,\n                paramsSwap[i].args\n            );\n            _addToList(listTokens, balanceTokens, address(paramsSwap[i].collateral), amountOut);\n        }\n\n        // Performing actions one after the others\n        for (uint256 i = 0; i < actions.length; i++) {\n            if (actions[i] == ActionType.claimRewards) {\n                (\n                    address user,\n                    uint256 proportionToBeTransferred,\n                    address[] memory claimLiquidityGauges,\n                    uint256[] memory claimPerpetualIDs,\n                    bool addressProcessed,\n                    address[] memory stablecoins,\n                    address[] memory collateralsOrPerpetualManagers\n                ) = abi.decode(data[i], (address, uint256, address[], uint256[], bool, address[], address[]));\n\n                uint256 amount = ANGLE.balanceOf(user);\n\n                _claimRewards(\n                    user,\n                    claimLiquidityGauges,\n                    claimPerpetualIDs,\n                    addressProcessed,\n                    stablecoins,\n                    collateralsOrPerpetualManagers\n                );\n                if (proportionToBeTransferred > 0) {\n                    amount = ANGLE.balanceOf(user) - amount;\n                    amount = (amount * proportionToBeTransferred) / BASE_PARAMS;\n                    ANGLE.safeTransferFrom(msg.sender, address(this), amount);\n                    _addToList(listTokens, balanceTokens, address(ANGLE), amount);\n                }\n            } else if (actions[i] == ActionType.claimWeeklyInterest) {\n                (address user, address feeDistributor, bool letInContract) = abi.decode(\n                    data[i],\n                    (address, address, bool)\n                );\n\n                (uint256 amount, IERC20 token) = _claimWeeklyInterest(\n                    user,\n                    IFeeDistributorFront(feeDistributor),\n                    letInContract\n                );\n                if (address(token) != address(0)) _addToList(listTokens, balanceTokens, address(token), amount);\n                // In all the following action, the `amount` variable represents the proportion of the\n                // balance that needs to be used for this action (in `BASE_PARAMS`)\n                // We name it `amount` here to save some new variable declaration costs\n            } else if (actions[i] == ActionType.veANGLEDeposit) {\n                (address user, uint256 amount) = abi.decode(data[i], (address, uint256));\n\n                amount = _computeProportion(amount, listTokens, balanceTokens, address(ANGLE));\n                _depositOnLocker(user, amount);\n            } else if (actions[i] == ActionType.gaugeDeposit) {\n                (address user, uint256 amount, address stakedToken, address gauge, bool shouldClaimRewards) = abi\n                    .decode(data[i], (address, uint256, address, address, bool));\n\n                amount = _computeProportion(amount, listTokens, balanceTokens, stakedToken);\n                _gaugeDeposit(user, amount, ILiquidityGauge(gauge), shouldClaimRewards);\n            } else if (actions[i] == ActionType.deposit) {\n                (\n                    address user,\n                    uint256 amount,\n                    bool addressProcessed,\n                    address stablecoinOrStableMaster,\n                    address collateral,\n                    address poolManager,\n                    address sanToken\n                ) = abi.decode(data[i], (address, uint256, bool, address, address, address, address));\n\n                amount = _computeProportion(amount, listTokens, balanceTokens, collateral);\n                (amount, sanToken) = _deposit(\n                    user,\n                    amount,\n                    addressProcessed,\n                    stablecoinOrStableMaster,\n                    collateral,\n                    IPoolManager(poolManager),\n                    ISanToken(sanToken)\n                );\n\n                if (amount > 0) _addToList(listTokens, balanceTokens, sanToken, amount);\n            } else if (actions[i] == ActionType.withdraw) {\n                (\n                    uint256 amount,\n                    bool addressProcessed,\n                    address stablecoinOrStableMaster,\n                    address collateralOrPoolManager,\n                    address sanToken\n                ) = abi.decode(data[i], (uint256, bool, address, address, address));\n\n                amount = _computeProportion(amount, listTokens, balanceTokens, sanToken);\n                // Reusing the `collateralOrPoolManager` variable to save some variable declarations\n                (amount, collateralOrPoolManager) = _withdraw(\n                    amount,\n                    addressProcessed,\n                    stablecoinOrStableMaster,\n                    collateralOrPoolManager\n                );\n                _addToList(listTokens, balanceTokens, collateralOrPoolManager, amount);\n            } else if (actions[i] == ActionType.mint) {\n                (\n                    address user,\n                    uint256 amount,\n                    uint256 minStableAmount,\n                    bool addressProcessed,\n                    address stablecoinOrStableMaster,\n                    address collateral,\n                    address poolManager\n                ) = abi.decode(data[i], (address, uint256, uint256, bool, address, address, address));\n\n                amount = _computeProportion(amount, listTokens, balanceTokens, collateral);\n                _mint(\n                    user,\n                    amount,\n                    minStableAmount,\n                    addressProcessed,\n                    stablecoinOrStableMaster,\n                    collateral,\n                    IPoolManager(poolManager)\n                );\n            } else if (actions[i] == ActionType.openPerpetual) {\n                (\n                    address user,\n                    uint256 amount,\n                    uint256 amountCommitted,\n                    uint256 extremeRateOracle,\n                    uint256 minNetMargin,\n                    bool addressProcessed,\n                    address stablecoinOrPerpetualManager,\n                    address collateral\n                ) = abi.decode(data[i], (address, uint256, uint256, uint256, uint256, bool, address, address));\n\n                amount = _computeProportion(amount, listTokens, balanceTokens, collateral);\n\n                _openPerpetual(\n                    user,\n                    amount,\n                    amountCommitted,\n                    extremeRateOracle,\n                    minNetMargin,\n                    addressProcessed,\n                    stablecoinOrPerpetualManager,\n                    collateral\n                );\n            } else if (actions[i] == ActionType.addToPerpetual) {\n                (\n                    uint256 amount,\n                    uint256 perpetualID,\n                    bool addressProcessed,\n                    address stablecoinOrPerpetualManager,\n                    address collateral\n                ) = abi.decode(data[i], (uint256, uint256, bool, address, address));\n\n                amount = _computeProportion(amount, listTokens, balanceTokens, collateral);\n                _addToPerpetual(amount, perpetualID, addressProcessed, stablecoinOrPerpetualManager, collateral);\n            } else if (actions[i] == ActionType.borrower) {\n                (\n                    address collateral,\n                    address stablecoin,\n                    address vaultManager,\n                    address to,\n                    address who,\n                    ActionBorrowType[] memory actionsBorrow,\n                    bytes[] memory dataBorrow,\n                    bytes memory repayData\n                ) = abi.decode(\n                        data[i],\n                        (address, address, address, address, address, ActionBorrowType[], bytes[], bytes)\n                    );\n                _parseVaultIDs(actionsBorrow, dataBorrow, vaultManager);\n                _changeAllowance(IERC20(collateral), address(vaultManager), type(uint256).max);\n                uint256 stablecoinBalance;\n                uint256 collateralBalance;\n                // In this case, this may mean that the `VaultManager` will engage in some way in a swap of stablecoins\n                // or collateral and we should not trust the amounts outputted by the `_angleBorrower` function as the true amounts\n                if (repayData.length > 0) {\n                    stablecoinBalance = IERC20(stablecoin).balanceOf(address(this));\n                    collateralBalance = IERC20(collateral).balanceOf(address(this));\n                }\n\n                PaymentData memory paymentData = _angleBorrower(\n                    vaultManager,\n                    actionsBorrow,\n                    dataBorrow,\n                    to,\n                    who,\n                    repayData\n                );\n\n                _changeAllowance(IERC20(collateral), address(vaultManager), 0);\n\n                if (repayData.length > 0) {\n                    paymentData.collateralAmountToGive = IERC20(collateral).balanceOf(address(this));\n                    paymentData.stablecoinAmountToGive = IERC20(stablecoin).balanceOf(address(this));\n                    paymentData.collateralAmountToReceive = collateralBalance;\n                    paymentData.stablecoinAmountToReceive = stablecoinBalance;\n                }\n\n                // Handle collateral transfers\n                if (paymentData.collateralAmountToReceive > paymentData.collateralAmountToGive) {\n                    uint256 index = _searchList(listTokens, collateral);\n                    balanceTokens[index] -= paymentData.collateralAmountToReceive - paymentData.collateralAmountToGive;\n                } else if (\n                    paymentData.collateralAmountToReceive < paymentData.collateralAmountToGive &&\n                    (to == address(this) || repayData.length > 0)\n                ) {\n                    _addToList(\n                        listTokens,\n                        balanceTokens,\n                        collateral,\n                        paymentData.collateralAmountToGive - paymentData.collateralAmountToReceive\n                    );\n                }\n                // Handle stablecoins transfers: the `VaultManager` is called with the `from` address being the `msg.sender`\n                // so we don't need to update the stablecoin balance if stablecoins are given to it from this operation as\n                // the `VaultManager` will call `burnFrom` and will just check that the router has allowance for the `msg.sender`\n                if (\n                    paymentData.stablecoinAmountToReceive < paymentData.stablecoinAmountToGive &&\n                    (to == address(this) || repayData.length > 0)\n                ) {\n                    _addToList(\n                        listTokens,\n                        balanceTokens,\n                        stablecoin,\n                        paymentData.stablecoinAmountToGive - paymentData.stablecoinAmountToReceive\n                    );\n                }\n            }\n        }\n\n        // Once all actions have been performed, the router sends back the unused funds from users\n        // If a user sends funds (through a swap) but specifies incorrectly the collateral associated to it, then\n        //  the mixer will revert when trying to send the remaining funds back\n        for (uint256 i = 0; i < balanceTokens.length; i++) {\n            if (balanceTokens[i] > 0) IERC20(listTokens[i]).safeTransfer(msg.sender, balanceTokens[i]);\n        }\n    }\n\n    /// @notice Wrapper built on top of the base `mixer` function to grant approval to a `VaultManager` contract before performing\n    /// actions and then revoking this approval after these actions\n    /// @param paramsPermitVaultManager Parameters to sign permit to give allowance to the router for a `VaultManager` contract\n    /// @dev In `paramsPermitVaultManager`, the signatures for granting approvals must be given first before the signatures\n    /// to revoke approvals\n    /// @dev The router contract has been built to be safe to keep approvals as you cannot take an action on a vault you are not\n    /// approved for, but people wary about their approvals may want to grant it before immediately revoking it, although this\n    /// is just an option\n    function mixerVaultManagerPermit(\n        PermitVaultManagerType[] memory paramsPermitVaultManager,\n        PermitType[] memory paramsPermit,\n        TransferType[] memory paramsTransfer,\n        ParamsSwapType[] memory paramsSwap,\n        ActionType[] memory actions,\n        bytes[] calldata data\n    ) external payable {\n        for (uint256 i = 0; i < paramsPermitVaultManager.length; i++) {\n            if (paramsPermitVaultManager[i].approved) {\n                IVaultManagerFunctions(paramsPermitVaultManager[i].vaultManager).permit(\n                    paramsPermitVaultManager[i].owner,\n                    address(this),\n                    true,\n                    paramsPermitVaultManager[i].deadline,\n                    paramsPermitVaultManager[i].v,\n                    paramsPermitVaultManager[i].r,\n                    paramsPermitVaultManager[i].s\n                );\n            } else break;\n        }\n        mixer(paramsPermit, paramsTransfer, paramsSwap, actions, data);\n        // Storing the index at which starting the iteration for revoking approvals in a variable would make the stack\n        // too deep\n        for (uint256 i = 0; i < paramsPermitVaultManager.length; i++) {\n            if (!paramsPermitVaultManager[i].approved) {\n                IVaultManagerFunctions(paramsPermitVaultManager[i].vaultManager).permit(\n                    paramsPermitVaultManager[i].owner,\n                    address(this),\n                    false,\n                    paramsPermitVaultManager[i].deadline,\n                    paramsPermitVaultManager[i].v,\n                    paramsPermitVaultManager[i].r,\n                    paramsPermitVaultManager[i].s\n                );\n            }\n        }\n    }\n\n    receive() external payable {}\n\n    // ======================== Internal Utility Functions =========================\n    // Most internal utility functions have a wrapper built on top of it\n\n    /// @notice Internal version of the `claimRewards` function\n    /// Allows to claim rewards for multiple gauges and perpetuals at once\n    /// @param gaugeUser Address for which to fetch the rewards from the gauges\n    /// @param liquidityGauges Gauges to claim on\n    /// @param perpetualIDs Perpetual IDs to claim rewards for\n    /// @param addressProcessed Whether `PerpetualManager` list is already accessible in `collateralsOrPerpetualManagers`vor if it should be\n    /// retrieved from `stablecoins` and `collateralsOrPerpetualManagers`\n    /// @param stablecoins Stablecoin contracts linked to the perpetualsIDs. Array of zero addresses if addressProcessed is true\n    /// @param collateralsOrPerpetualManagers Collateral contracts linked to the perpetualsIDs or `perpetualManager` contracts if\n    /// `addressProcessed` is true\n    /// @dev If the caller wants to send the rewards to another account than `gaugeUser` it first needs to\n    /// call `set_rewards_receiver(otherAccount)` on each `liquidityGauge`\n    /// @dev The function only takes rewards received by users,\n    function _claimRewards(\n        address gaugeUser,\n        address[] memory liquidityGauges,\n        uint256[] memory perpetualIDs,\n        bool addressProcessed,\n        address[] memory stablecoins,\n        address[] memory collateralsOrPerpetualManagers\n    ) internal {\n        if (stablecoins.length != perpetualIDs.length || collateralsOrPerpetualManagers.length != perpetualIDs.length)\n            revert IncompatibleLengths();\n\n        for (uint256 i = 0; i < liquidityGauges.length; i++) {\n            ILiquidityGauge(liquidityGauges[i]).claim_rewards(gaugeUser);\n        }\n\n        for (uint256 i = 0; i < perpetualIDs.length; i++) {\n            IPerpetualManagerFrontWithClaim perpManager;\n            if (addressProcessed) perpManager = IPerpetualManagerFrontWithClaim(collateralsOrPerpetualManagers[i]);\n            else {\n                (, Pairs memory pairs) = _getInternalContracts(\n                    IERC20(stablecoins[i]),\n                    IERC20(collateralsOrPerpetualManagers[i])\n                );\n                perpManager = pairs.perpetualManager;\n            }\n            perpManager.getReward(perpetualIDs[i]);\n        }\n    }\n\n    /// @notice Allows to deposit ANGLE on an existing locker\n    /// @param user Address to deposit for\n    /// @param amount Amount to deposit\n    function _depositOnLocker(address user, uint256 amount) internal {\n        VEANGLE.deposit_for(user, amount);\n    }\n\n    /// @notice Allows to call angle builder actions on VaultManager (Angle Protocol borrowing module)\n    /// @param vaultManager Address of the vault to perform actions on\n    /// @param actionsBorrow Actions type to perform on the vaultManager\n    /// @param dataBorrow Data needed for each actions\n    /// @param to Address to send the funds to\n    /// @param who Address Swapper to handle repayments\n    /// @param repayData Bytes to use at the discretion of the msg.sender\n    function _angleBorrower(\n        address vaultManager,\n        ActionBorrowType[] memory actionsBorrow,\n        bytes[] memory dataBorrow,\n        address to,\n        address who,\n        bytes memory repayData\n    ) internal returns (PaymentData memory paymentData) {\n        return IVaultManagerFunctions(vaultManager).angle(actionsBorrow, dataBorrow, msg.sender, to, who, repayData);\n    }\n\n    /// @notice Allows to claim weekly interest distribution and if wanted to transfer it to the `angleRouter` for future use\n    /// @param user Address to claim for\n    /// @param _feeDistributor Address of the fee distributor to claim to\n    /// @dev If funds are transferred to the router, this action cannot be an end in itself, otherwise funds will be lost:\n    /// typically we expect people to call for this action before doing a deposit\n    /// @dev If `letInContract` (and hence if funds are transferred to the router), you should approve the `angleRouter` to\n    /// transfer the token claimed from the `feeDistributor`\n    function _claimWeeklyInterest(\n        address user,\n        IFeeDistributorFront _feeDistributor,\n        bool letInContract\n    ) internal returns (uint256 amount, IERC20 token) {\n        amount = _feeDistributor.claim(user);\n        if (letInContract) {\n            // Fetching info from the `FeeDistributor` to process correctly the withdrawal\n            token = IERC20(_feeDistributor.token());\n            token.safeTransferFrom(msg.sender, address(this), amount);\n        } else {\n            amount = 0;\n        }\n    }\n\n    /// @notice Internal version of the `gaugeDeposit` function\n    /// Allows to deposit tokens into a gauge\n    /// @param user Address on behalf of which deposit should be made in the gauge\n    /// @param amount Amount to stake\n    /// @param gauge LiquidityGauge to stake in\n    /// @param shouldClaimRewards Whether to claim or not previously accumulated rewards\n    /// @dev You should be cautious on who will receive the rewards (if `shouldClaimRewards` is true)\n    /// It can be set on each gauge\n    /// @dev In the `mixer`, before calling for this action, user should have made sure to get in the router\n    /// the associated token (by like a  `deposit` action)\n    /// @dev The function will revert if the gauge has not already been approved by the contract\n    function _gaugeDeposit(\n        address user,\n        uint256 amount,\n        ILiquidityGauge gauge,\n        bool shouldClaimRewards\n    ) internal {\n        gauge.deposit(amount, user, shouldClaimRewards);\n    }\n\n    /// @notice Internal version of the `mint` functions\n    /// Mints stablecoins from the protocol\n    /// @param user Address to send the stablecoins to\n    /// @param amount Amount of collateral to use for the mint\n    /// @param minStableAmount Minimum stablecoin minted for the tx not to revert\n    /// @param addressProcessed Whether `msg.sender` provided the contracts address or the tokens one\n    /// @param stablecoinOrStableMaster Token associated to a `StableMaster` (if `addressProcessed` is false)\n    /// or directly the `StableMaster` contract if `addressProcessed`\n    /// @param collateral Collateral to mint from: it can be null if `addressProcessed` is true but in the corresponding\n    /// action, the `mixer` needs to get a correct address to compute the amount of tokens to use for the mint\n    /// @param poolManager PoolManager associated to the `collateral` (null if `addressProcessed` is not true)\n    /// @dev This function is not designed to be composable with other actions of the router after it's called: like\n    /// stablecoins obtained from it cannot be used for other operations: as such the `user` address should not be the router\n    /// address\n    function _mint(\n        address user,\n        uint256 amount,\n        uint256 minStableAmount,\n        bool addressProcessed,\n        address stablecoinOrStableMaster,\n        address collateral,\n        IPoolManager poolManager\n    ) internal {\n        IStableMasterFront stableMaster;\n        (stableMaster, poolManager) = _mintBurnContracts(\n            addressProcessed,\n            stablecoinOrStableMaster,\n            collateral,\n            poolManager\n        );\n        stableMaster.mint(amount, user, poolManager, minStableAmount);\n    }\n\n    /// @notice Burns stablecoins from the protocol\n    /// @param dest Address who will receive the proceeds\n    /// @param amount Amount of collateral to use for the mint\n    /// @param minCollatAmount Minimum Collateral minted for the tx not to revert\n    /// @param addressProcessed Whether `msg.sender` provided the contracts address or the tokens one\n    /// @param stablecoinOrStableMaster Token associated to a `StableMaster` (if `addressProcessed` is false)\n    /// or directly the `StableMaster` contract if `addressProcessed`\n    /// @param collateral Collateral to mint from: it can be null if `addressProcessed` is true but in the corresponding\n    /// action, the `mixer` needs to get a correct address to compute the amount of tokens to use for the mint\n    /// @param poolManager PoolManager associated to the `collateral` (null if `addressProcessed` is not true)\n    function _burn(\n        address dest,\n        uint256 amount,\n        uint256 minCollatAmount,\n        bool addressProcessed,\n        address stablecoinOrStableMaster,\n        address collateral,\n        IPoolManager poolManager\n    ) internal {\n        IStableMasterFront stableMaster;\n        (stableMaster, poolManager) = _mintBurnContracts(\n            addressProcessed,\n            stablecoinOrStableMaster,\n            collateral,\n            poolManager\n        );\n        stableMaster.burn(amount, msg.sender, dest, poolManager, minCollatAmount);\n    }\n\n    /// @notice Internal version of the `deposit` functions\n    /// Allows to deposit a collateral within the protocol\n    /// @param user Address where to send the resulting sanTokens, if this address is the router address then it means\n    /// that the intention is to stake the sanTokens obtained in a subsequent `gaugeDeposit` action\n    /// @param amount Amount of collateral to deposit\n    /// @param addressProcessed Whether `msg.sender` provided the contracts addresses or the tokens ones\n    /// @param stablecoinOrStableMaster Token associated to a `StableMaster` (if `addressProcessed` is false)\n    /// or directly the `StableMaster` contract if `addressProcessed`\n    /// @param collateral Token to deposit: it can be null if `addressProcessed` is true but in the corresponding\n    /// action, the `mixer` needs to get a correct address to compute the amount of tokens to use for the deposit\n    /// @param poolManager PoolManager associated to the `collateral` (null if `addressProcessed` is not true)\n    /// @param sanToken SanToken associated to the `collateral` (null if `addressProcessed` is not true)\n    /// @dev Contrary to the `mint` action, the `deposit` action can be used in composition with other actions, like\n    /// `deposit` and then `stake`\n    function _deposit(\n        address user,\n        uint256 amount,\n        bool addressProcessed,\n        address stablecoinOrStableMaster,\n        address collateral,\n        IPoolManager poolManager,\n        ISanToken sanToken\n    ) internal returns (uint256 addedAmount, address) {\n        IStableMasterFront stableMaster;\n        if (addressProcessed) {\n            stableMaster = IStableMasterFront(stablecoinOrStableMaster);\n        } else {\n            Pairs memory pairs;\n            (stableMaster, pairs) = _getInternalContracts(IERC20(stablecoinOrStableMaster), IERC20(collateral));\n            poolManager = pairs.poolManager;\n            sanToken = pairs.sanToken;\n        }\n\n        if (user == address(this)) {\n            // Computing the amount of sanTokens obtained\n            addedAmount = sanToken.balanceOf(address(this));\n            stableMaster.deposit(amount, address(this), poolManager);\n            addedAmount = sanToken.balanceOf(address(this)) - addedAmount;\n        } else {\n            stableMaster.deposit(amount, user, poolManager);\n        }\n        return (addedAmount, address(sanToken));\n    }\n\n    /// @notice Withdraws sanTokens from the protocol\n    /// @param amount Amount of sanTokens to withdraw\n    /// @param addressProcessed Whether `msg.sender` provided the contracts addresses or the tokens ones\n    /// @param stablecoinOrStableMaster Token associated to a `StableMaster` (if `addressProcessed` is false)\n    /// or directly the `StableMaster` contract if `addressProcessed`\n    /// @param collateralOrPoolManager Collateral to withdraw (if `addressProcessed` is false) or directly\n    /// the `PoolManager` contract if `addressProcessed`\n    function _withdraw(\n        uint256 amount,\n        bool addressProcessed,\n        address stablecoinOrStableMaster,\n        address collateralOrPoolManager\n    ) internal returns (uint256 withdrawnAmount, address) {\n        IStableMasterFront stableMaster;\n        // Stores the address of the `poolManager`, while `collateralOrPoolManager` is used in the function\n        // to store the `collateral` address\n        IPoolManager poolManager;\n        if (addressProcessed) {\n            stableMaster = IStableMasterFront(stablecoinOrStableMaster);\n            poolManager = IPoolManager(collateralOrPoolManager);\n            collateralOrPoolManager = poolManager.token();\n        } else {\n            Pairs memory pairs;\n            (stableMaster, pairs) = _getInternalContracts(\n                IERC20(stablecoinOrStableMaster),\n                IERC20(collateralOrPoolManager)\n            );\n            poolManager = pairs.poolManager;\n        }\n        // Here reusing the `withdrawnAmount` variable to avoid a stack too deep problem\n        withdrawnAmount = IERC20(collateralOrPoolManager).balanceOf(address(this));\n\n        // This call will increase our collateral balance\n        stableMaster.withdraw(amount, address(this), address(this), poolManager);\n\n        // We compute the difference between our collateral balance after and before the `withdraw` call\n        withdrawnAmount = IERC20(collateralOrPoolManager).balanceOf(address(this)) - withdrawnAmount;\n\n        return (withdrawnAmount, collateralOrPoolManager);\n    }\n\n    /// @notice Internal version of the `openPerpetual` function\n    /// Opens a perpetual within Angle\n    /// @param owner Address to mint perpetual for\n    /// @param margin Margin to open the perpetual with\n    /// @param amountCommitted Commit amount in the perpetual\n    /// @param maxOracleRate Maximum oracle rate required to have a leverage position opened\n    /// @param minNetMargin Minimum net margin required to have a leverage position opened\n    /// @param addressProcessed Whether msg.sender provided the contracts addresses or the tokens ones\n    /// @param stablecoinOrPerpetualManager Token associated to the `StableMaster` (iif `addressProcessed` is false)\n    /// or address of the desired `PerpetualManager` (if `addressProcessed` is true)\n    /// @param collateral Collateral to mint from (it can be null if `addressProcessed` is true): it can be null if `addressProcessed` is true but in the corresponding\n    /// action, the `mixer` needs to get a correct address to compute the amount of tokens to use for the deposit\n    function _openPerpetual(\n        address owner,\n        uint256 margin,\n        uint256 amountCommitted,\n        uint256 maxOracleRate,\n        uint256 minNetMargin,\n        bool addressProcessed,\n        address stablecoinOrPerpetualManager,\n        address collateral\n    ) internal returns (uint256 perpetualID) {\n        if (!addressProcessed) {\n            (, Pairs memory pairs) = _getInternalContracts(IERC20(stablecoinOrPerpetualManager), IERC20(collateral));\n            stablecoinOrPerpetualManager = address(pairs.perpetualManager);\n        }\n\n        return\n            IPerpetualManagerFrontWithClaim(stablecoinOrPerpetualManager).openPerpetual(\n                owner,\n                margin,\n                amountCommitted,\n                maxOracleRate,\n                minNetMargin\n            );\n    }\n\n    /// @notice Internal version of the `addToPerpetual` function\n    /// Adds collateral to a perpetual\n    /// @param margin Amount of collateral to add\n    /// @param perpetualID Perpetual to add collateral to\n    /// @param addressProcessed Whether msg.sender provided the contracts addresses or the tokens ones\n    /// @param stablecoinOrPerpetualManager Token associated to the `StableMaster` (iif `addressProcessed` is false)\n    /// or address of the desired `PerpetualManager` (if `addressProcessed` is true)\n    /// @param collateral Collateral to mint from (it can be null if `addressProcessed` is true): it can be null if `addressProcessed` is true but in the corresponding\n    /// action, the `mixer` needs to get a correct address to compute the amount of tokens to use for the deposit\n    function _addToPerpetual(\n        uint256 margin,\n        uint256 perpetualID,\n        bool addressProcessed,\n        address stablecoinOrPerpetualManager,\n        address collateral\n    ) internal {\n        if (!addressProcessed) {\n            (, Pairs memory pairs) = _getInternalContracts(IERC20(stablecoinOrPerpetualManager), IERC20(collateral));\n            stablecoinOrPerpetualManager = address(pairs.perpetualManager);\n        }\n        IPerpetualManagerFrontWithClaim(stablecoinOrPerpetualManager).addToPerpetual(perpetualID, margin);\n    }\n\n    // ======================== Internal Utility Functions =========================\n\n    /// @notice Parses the actions submitted to the router contract to interact with a `VaultManager` and makes sure that\n    /// the calling address is well approved for all the vaults with which it is interacting\n    /// @dev If such check was not made, we could end up in a situation where an address has given an approval for all its\n    /// vaults to the router contract, and another address takes advantage of this to instruct actions on these other vaults\n    /// to the router: it is hence super important for the router to pay attention to the fact that the addresses interacting\n    /// with a vault are approved for this vault\n    function _parseVaultIDs(\n        ActionBorrowType[] memory actionsBorrow,\n        bytes[] memory dataBorrow,\n        address vaultManager\n    ) internal view {\n        if (actionsBorrow.length >= _MAX_TOKENS) revert IncompatibleLengths();\n        // The amount of vaults to check cannot be bigger than the maximum amount of tokens\n        // supported\n        uint256[_MAX_TOKENS] memory vaultIDsToCheckOwnershipOf;\n        bool createVaultAction;\n        uint256 lastVaultID;\n        uint256 vaultIDLength;\n        for (uint256 i = 0; i < actionsBorrow.length; i++) {\n            uint256 vaultID;\n            // If there is a createVault action, the router should not worry about looking at\n            // next vaultIDs given equal to 0\n            if (actionsBorrow[i] == ActionBorrowType.createVault) {\n                createVaultAction = true;\n                continue;\n            // There are then different ways depending on the action to find the `vaultID`\n            } else if (\n                actionsBorrow[i] == ActionBorrowType.removeCollateral || actionsBorrow[i] == ActionBorrowType.borrow\n            ) {\n                (vaultID, ) = abi.decode(dataBorrow[i], (uint256, uint256));\n            } else if (actionsBorrow[i] == ActionBorrowType.closeVault) {\n                vaultID = abi.decode(dataBorrow[i], (uint256));\n            } else if (actionsBorrow[i] == ActionBorrowType.getDebtIn) {\n                (vaultID, , , ) = abi.decode(dataBorrow[i], (uint256, address, uint256, uint256));\n            } else continue;\n            // If we need to add a null `vaultID`, we look at the `vaultIDCount` in the `VaultManager`\n            // if there has not been any specific action\n            if (vaultID == 0) {\n                if (createVaultAction) {\n                    continue;\n                } else {\n                    // If we haven't stored the last `vaultID`, we need to fetch it\n                    if (lastVaultID == 0) {\n                        lastVaultID = IVaultManagerStorage(vaultManager).vaultIDCount();\n                    }\n                    vaultID = lastVaultID;\n                }\n            }\n\n            // Check if this `vaultID` has already been verified\n            for (uint256 j = 0; j < vaultIDLength; j++) {\n                if (vaultIDsToCheckOwnershipOf[j] == vaultID) {\n                    // If yes, we continue to the next iteration\n                    continue;\n                }\n            }\n            // Verify this new vaultID and add it to the list\n            if (!IVaultManagerFunctions(vaultManager).isApprovedOrOwner(msg.sender, vaultID)) {\n                revert NotApprovedOrOwner();\n            }\n            vaultIDsToCheckOwnershipOf[vaultIDLength] = vaultID;\n            vaultIDLength += 1;\n        }\n    }\n\n    /// @notice Checks if collateral in the list\n    /// @param list List of addresses\n    /// @param searchFor Address of interest\n    /// @return index Place of the address in the list if it is in or current length otherwise\n    function _searchList(address[_MAX_TOKENS] memory list, address searchFor) internal pure returns (uint256 index) {\n        uint256 i;\n        while (i < list.length && list[i] != address(0)) {\n            if (list[i] == searchFor) return i;\n            i++;\n        }\n        return i;\n    }\n\n    /// @notice Modifies stored balances for a given collateral\n    /// @param list List of collateral addresses\n    /// @param balances List of balances for the different supported collateral types\n    /// @param searchFor Address of the collateral of interest\n    /// @param amount Amount to add in the balance for this collateral\n    function _addToList(\n        address[_MAX_TOKENS] memory list,\n        uint256[_MAX_TOKENS] memory balances,\n        address searchFor,\n        uint256 amount\n    ) internal pure {\n        uint256 index = _searchList(list, searchFor);\n        // add it to the list if non existent and we add tokens\n        if (list[index] == address(0)) list[index] = searchFor;\n        balances[index] += amount;\n    }\n\n    /// @notice Computes the proportion of the collateral leftover balance to use for a given action\n    /// @param proportion Ratio to take from balance\n    /// @param list Collateral list\n    /// @param balances Balances of each collateral asset in the collateral list\n    /// @param searchFor Collateral to look for\n    /// @return amount Amount to use for the action (based on the proportion given)\n    /// @dev To use all the collateral balance available for an action, users should give `proportion` a value of\n    /// `BASE_PARAMS`\n    function _computeProportion(\n        uint256 proportion,\n        address[_MAX_TOKENS] memory list,\n        uint256[_MAX_TOKENS] memory balances,\n        address searchFor\n    ) internal pure returns (uint256 amount) {\n        uint256 index = _searchList(list, searchFor);\n\n        // Reverts if the index was not found\n        if (list[index] == address(0)) revert InvalidConditions();\n\n        amount = (proportion * balances[index]) / BASE_PARAMS;\n        balances[index] -= amount;\n    }\n\n    /// @notice Gets Angle contracts associated to a pair (stablecoin, collateral)\n    /// @param stablecoin Token associated to a `StableMaster`\n    /// @param collateral Collateral to mint/deposit/open perpetual or add collateral from\n    /// @dev This function is used to check that the parameters passed by people calling some of the main\n    /// router functions are correct\n    function _getInternalContracts(IERC20 stablecoin, IERC20 collateral)\n        internal\n        view\n        returns (IStableMasterFront stableMaster, Pairs memory pairs)\n    {\n        stableMaster = mapStableMasters[stablecoin];\n        pairs = mapPoolManagers[stableMaster][collateral];\n        // If `stablecoin` is zero then this necessarily means that `stableMaster` here will be 0\n        // Similarly, if `collateral` is zero, then this means that `pairs.perpetualManager`, `pairs.poolManager`\n        // and `pairs.sanToken` will be zero\n        // Last, if any of `pairs.perpetualManager`, `pairs.poolManager` or `pairs.sanToken` is zero, this means\n        // that all others should be null from the `addPairs` and `removePairs` functions which keep this invariant\n        if (address(stableMaster) == address(0) || address(pairs.poolManager) == address(0)) revert ZeroAddress();\n\n        return (stableMaster, pairs);\n    }\n\n    /// @notice Get contracts for mint and burn actions\n    /// @param addressProcessed Whether `msg.sender` provided the contracts address or the tokens one\n    /// @param stablecoinOrStableMaster Token associated to a `StableMaster` (if `addressProcessed` is false)\n    /// or directly the `StableMaster` contract if `addressProcessed`\n    /// @param collateral Collateral to mint from: it can be null if `addressProcessed` is true but in the corresponding\n    /// action, the `mixer` needs to get a correct address to compute the amount of tokens to use for the mint\n    /// @param poolManager PoolManager associated to the `collateral` (null if `addressProcessed` is not true)\n    function _mintBurnContracts(\n        bool addressProcessed,\n        address stablecoinOrStableMaster,\n        address collateral,\n        IPoolManager poolManager\n    ) internal view returns (IStableMasterFront, IPoolManager) {\n        IStableMasterFront stableMaster;\n        if (addressProcessed) {\n            stableMaster = IStableMasterFront(stablecoinOrStableMaster);\n        } else {\n            Pairs memory pairs;\n            (stableMaster, pairs) = _getInternalContracts(IERC20(stablecoinOrStableMaster), IERC20(collateral));\n            poolManager = pairs.poolManager;\n        }\n        return (stableMaster, poolManager);\n    }\n\n    /// @notice Adds new collateral type to specific stablecoin\n    /// @param stableMaster Address of the `StableMaster` associated to the stablecoin of interest\n    /// @param poolManager Address of the `PoolManager` contract associated to the pair (stablecoin,collateral)\n    /// @param liquidityGauge Address of liquidity gauge contract associated to sanToken\n    function _addPair(\n        IStableMasterFront stableMaster,\n        IPoolManager poolManager,\n        ILiquidityGauge liquidityGauge\n    ) internal {\n        // Fetching the associated `sanToken` and `perpetualManager` from the contract\n        (IERC20 collateral, ISanToken sanToken, IPerpetualManager perpetualManager, , , , , , ) = IStableMaster(\n            address(stableMaster)\n        ).collateralMap(poolManager);\n\n        Pairs storage _pairs = mapPoolManagers[stableMaster][collateral];\n        // Checking if the pair has not already been initialized: if yes we need to make the function revert\n        // otherwise we could end up with still approved `PoolManager` and `PerpetualManager` contracts\n        if (address(_pairs.poolManager) != address(0)) revert AlreadyAdded();\n\n        _pairs.poolManager = poolManager;\n        _pairs.perpetualManager = IPerpetualManagerFrontWithClaim(address(perpetualManager));\n        _pairs.sanToken = sanToken;\n        // In the future, it is possible that sanTokens do not have an associated liquidity gauge\n        if (address(liquidityGauge) != address(0)) {\n            if (address(sanToken) != liquidityGauge.staking_token()) revert InvalidToken();\n            _pairs.gauge = liquidityGauge;\n            sanToken.approve(address(liquidityGauge), type(uint256).max);\n        }\n        _changeAllowance(collateral, address(stableMaster), type(uint256).max);\n        _changeAllowance(collateral, address(perpetualManager), type(uint256).max);\n        emit CollateralToggled(address(stableMaster), address(poolManager), address(liquidityGauge));\n    }\n\n    /// @notice Changes allowance of this contract for a given token\n    /// @param token Address of the token to change allowance\n    /// @param spender Address to change the allowance of\n    /// @param amount Amount allowed\n    function _changeAllowance(\n        IERC20 token,\n        address spender,\n        uint256 amount\n    ) internal {\n        uint256 currentAllowance = token.allowance(address(this), spender);\n        if (currentAllowance < amount) {\n            token.safeIncreaseAllowance(spender, amount - currentAllowance);\n        } else if (currentAllowance > amount) {\n            token.safeDecreaseAllowance(spender, currentAllowance - amount);\n        }\n    }\n\n    /// @notice Transfers collateral or an arbitrary token which is then swapped on UniswapV3 or on 1Inch\n    /// @param inToken Token to swap for the collateral\n    /// @param amount Amount of in token to swap for the collateral\n    /// @param minAmountOut Minimum amount accepted for the swap to happen\n    /// @param swapType Choice on which contracts to swap\n    /// @param args Bytes representing either the path to swap your input token to the accepted collateral on Uniswap or payload for 1Inch\n    /// @dev The `path` provided is not checked, meaning people could swap for a token A and declare that they've swapped for another token B.\n    /// However, the mixer manipulates its token balance only through the addresses registered in `listTokens`, so any subsequent mixer action\n    /// trying to transfer funds B will do it through address of token A and revert as A is not actually funded.\n    /// In case there is not subsequent action, `mixer` will revert when trying to send back what appears to be remaining tokens A.\n    function _transferAndSwap(\n        IERC20 inToken,\n        uint256 amount,\n        uint256 minAmountOut,\n        SwapType swapType,\n        bytes memory args\n    ) internal returns (uint256) {\n        if (address(this).balance >= amount) {\n            if (address(inToken) == address(WETH9)) {\n                WETH9.deposit{ value: amount }(); // wrap only what is needed to pay\n            } else if (address(inToken) == address(WSTETH)) {\n                uint256 amountOut = STETH.getSharesByPooledEth(amount);\n                //solhint-disable-next-line\n                (bool success, bytes memory result) = address(WSTETH).call{ value: amount }(\"\");\n                if (!success) _revertBytes(result);\n                amount = amountOut;\n            }\n        } else {\n            inToken.safeTransferFrom(msg.sender, address(this), amount);\n        }\n        return _swap(inToken, amount, minAmountOut, swapType, args);\n    }\n\n    /// @notice swap an amount of inToken\n    /// @param inToken Token to swap for the collateral\n    /// @param amount Amount of in token to swap for the collateral\n    /// @param minAmountOut Minimum amount accepted for the swap to happen\n    /// @param swapType Choice on which contracts to swap\n    function _swap(\n        IERC20 inToken,\n        uint256 amount,\n        uint256 minAmountOut,\n        SwapType swapType,\n        bytes memory args\n    ) internal returns (uint256 amountOut) {\n        if (swapType == SwapType.UniswapV3) amountOut = _swapOnUniswapV3(inToken, amount, minAmountOut, args);\n        else if (swapType == SwapType.oneINCH) amountOut = _swapOn1Inch(inToken, args);\n        else if (swapType == SwapType.WrapStETH) amountOut = WSTETH.wrap(amount);\n        else if (swapType == SwapType.None) amountOut = amount;\n        else revert InvalidCall();\n        if (amountOut < minAmountOut) revert TooSmallAmountOut();\n    }\n\n    /// @notice Allows to swap any token to an accepted collateral via UniswapV3 (if there is a path)\n    /// @param inToken Address token used as entrance of the swap\n    /// @param amount Amount of in token to swap for the accepted collateral\n    /// @param minAmountOut Minimum amount accepted for the swap to happen\n    /// @param path Bytes representing the path to swap your input token to the accepted collateral\n    function _swapOnUniswapV3(\n        IERC20 inToken,\n        uint256 amount,\n        uint256 minAmountOut,\n        bytes memory path\n    ) internal returns (uint256 amountOut) {\n        // Approve transfer to the `uniswapV3Router` if it is the first time that the token is used\n        if (!uniAllowedToken[inToken]) {\n            inToken.safeApprove(address(uniswapV3Router), type(uint256).max);\n            uniAllowedToken[inToken] = true;\n        }\n        amountOut = uniswapV3Router.exactInput(\n            ExactInputParams(path, address(this), block.timestamp, amount, minAmountOut)\n        );\n    }\n\n    /// @notice Allows to swap any token to an accepted collateral via 1Inch Router\n    /// @param payload Bytes needed for 1Inch router to process the swap\n    /// @dev The `payload` given is expected to be obtained from 1Inch API\n    function _swapOn1Inch(\n        IERC20 inToken,\n        bytes memory payload\n    ) internal returns (uint256 amountOut) {\n        // Approve transfer to the `oneInch` router if it is the first time the token is used\n        if (!oneInchAllowedToken[inToken]) {\n            inToken.safeApprove(address(oneInch), type(uint256).max);\n            oneInchAllowedToken[inToken] = true;\n        }\n\n        //solhint-disable-next-line\n        (bool success, bytes memory result) = oneInch.call(payload);\n        if (!success) _revertBytes(result);\n\n        amountOut = abi.decode(result, (uint256));\n    }\n\n    /// @notice Internal function used for error handling\n    function _revertBytes(bytes memory errMsg) internal pure {\n        if (errMsg.length > 0) {\n            //solhint-disable-next-line\n            assembly {\n                revert(add(32, errMsg), mload(errMsg))\n            }\n        }\n        revert InvalidReturnMessage();\n    }\n\n    /* For context, we give here the initialize function that was used for this contract in another implementation\n    /// @notice Deploys the `AngleRouter` contract\n    /// @param _governor Governor address\n    /// @param _guardian Guardian address\n    /// @param _uniswapV3Router UniswapV3 router address\n    /// @param _oneInch 1Inch aggregator address\n    /// @param existingStableMaster Address of the existing `StableMaster`\n    /// @param existingPoolManagers Addresses of the associated poolManagers\n    /// @param existingLiquidityGauges Addresses of liquidity gauge contracts associated to sanTokens\n    /// @dev Be cautious with safe approvals, all tokens will have unlimited approvals within the protocol or\n    /// UniswapV3 and 1Inch\n    function initialize(\n        address _governor,\n        address _guardian,\n        IUniswapV3Router _uniswapV3Router,\n        address _oneInch,\n        IStableMasterFront existingStableMaster,\n        IPoolManager[] calldata existingPoolManagers,\n        ILiquidityGauge[] calldata existingLiquidityGauges\n    ) public initializer {\n        // Checking the parameters passed\n        require(\n            address(_uniswapV3Router) != address(0) &&\n                _oneInch != address(0) &&\n                _governor != address(0) &&\n                _guardian != address(0),\n            \"0\"\n        );\n        require(_governor != _guardian, \"49\");\n        require(existingPoolManagers.length == existingLiquidityGauges.length, \"104\");\n        // Fetching the stablecoin and mapping it to the `StableMaster`\n        mapStableMasters[\n            IERC20(address(IStableMaster(address(existingStableMaster)).agToken()))\n        ] = existingStableMaster;\n        // Setting roles\n        governor = _governor;\n        guardian = _guardian;\n        uniswapV3Router = _uniswapV3Router;\n        oneInch = _oneInch;\n\n        // for veANGLEDeposit action\n        ANGLE.safeApprove(address(VEANGLE), type(uint256).max);\n\n        for (uint256 i = 0; i < existingPoolManagers.length; i++) {\n            _addPair(existingStableMaster, existingPoolManagers[i], existingLiquidityGauges[i]);\n        }\n    }\n    */\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IFeeDistributor.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\n/// @title IFeeDistributor\n/// @author Interface of the `FeeDistributor` contract\n/// @dev This interface is used by the `SurplusConverter` contract to send funds to the `FeeDistributor`\ninterface IFeeDistributor {\n    function burn(address token) external;\n}\n\n/// @title IFeeDistributorFront\n/// @author Interface for public use of the `FeeDistributor` contract\n/// @dev This interface is used for user related function\ninterface IFeeDistributorFront {\n    function token() external returns (address);\n\n    function claim(address _addr) external returns (uint256);\n\n    function claim(address[20] memory _addr) external returns (bool);\n}\n"
    },
    "contracts/interfaces/ILiquidityGauge.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\ninterface ILiquidityGauge {\n    // solhint-disable-next-line\n    function staking_token() external returns (address stakingToken);\n\n    // solhint-disable-next-line\n    function deposit_reward_token(address _rewardToken, uint256 _amount) external;\n\n    function deposit(\n        uint256 _value,\n        address _addr,\n        // solhint-disable-next-line\n        bool _claim_rewards\n    ) external;\n\n    // solhint-disable-next-line\n    function claim_rewards(address _addr) external;\n\n    // solhint-disable-next-line\n    function claim_rewards(address _addr, address _receiver) external;\n}\n"
    },
    "contracts/interfaces/ISanToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\n/// @title ISanToken\n/// @author Angle Core Team\n/// @notice Interface for Angle's `SanToken` contract that handles sanTokens, tokens that are given to SLPs\n/// contributing to a collateral for a given stablecoin\ninterface ISanToken is IERC20Upgradeable {\n    // ================================== StableMaster =============================\n\n    function mint(address account, uint256 amount) external;\n\n    function burnFrom(\n        uint256 amount,\n        address burner,\n        address sender\n    ) external;\n\n    function burnSelf(uint256 amount, address burner) external;\n\n    function stableMaster() external view returns (address);\n\n    function poolManager() external view returns (address);\n}\n"
    },
    "contracts/interfaces/IStableMaster.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n// Normally just importing `IPoolManager` should be sufficient, but for clarity here\n// we prefer to import all concerned interfaces\nimport \"./IPoolManager.sol\";\nimport \"./IOracle.sol\";\nimport \"./IPerpetualManager.sol\";\nimport \"./ISanToken.sol\";\n\n// Struct to handle all the parameters to manage the fees\n// related to a given collateral pool (associated to the stablecoin)\nstruct MintBurnData {\n    // Values of the thresholds to compute the minting fees\n    // depending on HA hedge (scaled by `BASE_PARAMS`)\n    uint64[] xFeeMint;\n    // Values of the fees at thresholds (scaled by `BASE_PARAMS`)\n    uint64[] yFeeMint;\n    // Values of the thresholds to compute the burning fees\n    // depending on HA hedge (scaled by `BASE_PARAMS`)\n    uint64[] xFeeBurn;\n    // Values of the fees at thresholds (scaled by `BASE_PARAMS`)\n    uint64[] yFeeBurn;\n    // Max proportion of collateral from users that can be covered by HAs\n    // It is exactly the same as the parameter of the same name in `PerpetualManager`, whenever one is updated\n    // the other changes accordingly\n    uint64 targetHAHedge;\n    // Minting fees correction set by the `FeeManager` contract: they are going to be multiplied\n    // to the value of the fees computed using the hedge curve\n    // Scaled by `BASE_PARAMS`\n    uint64 bonusMalusMint;\n    // Burning fees correction set by the `FeeManager` contract: they are going to be multiplied\n    // to the value of the fees computed using the hedge curve\n    // Scaled by `BASE_PARAMS`\n    uint64 bonusMalusBurn;\n    // Parameter used to limit the number of stablecoins that can be issued using the concerned collateral\n    uint256 capOnStableMinted;\n}\n\n// Struct to handle all the variables and parameters to handle SLPs in the protocol\n// including the fraction of interests they receive or the fees to be distributed to\n// them\nstruct SLPData {\n    // Last timestamp at which the `sanRate` has been updated for SLPs\n    uint256 lastBlockUpdated;\n    // Fees accumulated from previous blocks and to be distributed to SLPs\n    uint256 lockedInterests;\n    // Max interests used to update the `sanRate` in a single block\n    // Should be in collateral token base\n    uint256 maxInterestsDistributed;\n    // Amount of fees left aside for SLPs and that will be distributed\n    // when the protocol is collateralized back again\n    uint256 feesAside;\n    // Part of the fees normally going to SLPs that is left aside\n    // before the protocol is collateralized back again (depends on collateral ratio)\n    // Updated by keepers and scaled by `BASE_PARAMS`\n    uint64 slippageFee;\n    // Portion of the fees from users minting and burning\n    // that goes to SLPs (the rest goes to surplus)\n    uint64 feesForSLPs;\n    // Slippage factor that's applied to SLPs exiting (depends on collateral ratio)\n    // If `slippage = BASE_PARAMS`, SLPs can get nothing, if `slippage = 0` they get their full claim\n    // Updated by keepers and scaled by `BASE_PARAMS`\n    uint64 slippage;\n    // Portion of the interests from lending\n    // that goes to SLPs (the rest goes to surplus)\n    uint64 interestsForSLPs;\n}\n\n/// @title IStableMasterFunctions\n/// @author Angle Core Team\n/// @notice Interface for the `StableMaster` contract\ninterface IStableMasterFunctions {\n    function deploy(\n        address[] memory _governorList,\n        address _guardian,\n        address _agToken\n    ) external;\n\n    // ============================== Lending ======================================\n\n    function accumulateInterest(uint256 gain) external;\n\n    function signalLoss(uint256 loss) external;\n\n    // ============================== HAs ==========================================\n\n    function getStocksUsers() external view returns (uint256 maxCAmountInStable);\n\n    function convertToSLP(uint256 amount, address user) external;\n\n    // ============================== Keepers ======================================\n\n    function getCollateralRatio() external returns (uint256);\n\n    function setFeeKeeper(\n        uint64 feeMint,\n        uint64 feeBurn,\n        uint64 _slippage,\n        uint64 _slippageFee\n    ) external;\n\n    // ============================== AgToken ======================================\n\n    function updateStocksUsers(uint256 amount, address poolManager) external;\n\n    // ============================= Governance ====================================\n\n    function setCore(address newCore) external;\n\n    function addGovernor(address _governor) external;\n\n    function removeGovernor(address _governor) external;\n\n    function setGuardian(address newGuardian, address oldGuardian) external;\n\n    function revokeGuardian(address oldGuardian) external;\n\n    function setCapOnStableAndMaxInterests(\n        uint256 _capOnStableMinted,\n        uint256 _maxInterestsDistributed,\n        IPoolManager poolManager\n    ) external;\n\n    function setIncentivesForSLPs(\n        uint64 _feesForSLPs,\n        uint64 _interestsForSLPs,\n        IPoolManager poolManager\n    ) external;\n\n    function setUserFees(\n        IPoolManager poolManager,\n        uint64[] memory _xFee,\n        uint64[] memory _yFee,\n        uint8 _mint\n    ) external;\n\n    function setTargetHAHedge(uint64 _targetHAHedge) external;\n\n    function pause(bytes32 agent, IPoolManager poolManager) external;\n\n    function unpause(bytes32 agent, IPoolManager poolManager) external;\n}\n\n/// @title IStableMaster\n/// @author Angle Core Team\n/// @notice Previous interface with additionnal getters for public variables and mappings\ninterface IStableMaster is IStableMasterFunctions {\n    function agToken() external view returns (address);\n\n    function collateralMap(IPoolManager poolManager)\n        external\n        view\n        returns (\n            IERC20 token,\n            ISanToken sanToken,\n            IPerpetualManager perpetualManager,\n            IOracle oracle,\n            uint256 stocksUsers,\n            uint256 sanRate,\n            uint256 collatBase,\n            SLPData memory slpData,\n            MintBurnData memory feeData\n        );\n}\n"
    },
    "contracts/interfaces/IStableMasterFront.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"../interfaces/IPoolManager.sol\";\n\n/// @title IStableMasterFront\n/// @author Angle Core Team\n/// @dev Front interface, meaning only user-facing functions\ninterface IStableMasterFront {\n    function mint(\n        uint256 amount,\n        address user,\n        IPoolManager poolManager,\n        uint256 minStableAmount\n    ) external;\n\n    function burn(\n        uint256 amount,\n        address burner,\n        address dest,\n        IPoolManager poolManager,\n        uint256 minCollatAmount\n    ) external;\n\n    function deposit(\n        uint256 amount,\n        address user,\n        IPoolManager poolManager\n    ) external;\n\n    function withdraw(\n        uint256 amount,\n        address burner,\n        address dest,\n        IPoolManager poolManager\n    ) external;\n\n    function agToken() external returns (address);\n}\n"
    },
    "contracts/interfaces/IVeANGLE.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\n/// @title IVeANGLE\n/// @author Angle Core Team\n/// @notice Interface for the `VeANGLE` contract\ninterface IVeANGLE {\n    // solhint-disable-next-line func-name-mixedcase\n    function deposit_for(address addr, uint256 amount) external;\n}\n"
    },
    "contracts/interfaces/external/IWETH9.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title Interface for WETH9\ninterface IWETH9 is IERC20 {\n    /// @notice Deposit ether to get wrapped ether\n    function deposit() external payable;\n\n    /// @notice Withdraw wrapped ether to get ether\n    function withdraw(uint256) external;\n}\n"
    },
    "contracts/interfaces/external/uniswap/IUniswapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nstruct ExactInputParams {\n    bytes path;\n    address recipient;\n    uint256 deadline;\n    uint256 amountIn;\n    uint256 amountOutMinimum;\n}\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface IUniswapV3Router {\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n}\n\n/// @title Router for price estimation functionality\n/// @notice Functions for getting the price of one token with respect to another using Uniswap V2\n/// @dev This interface is only used for non critical elements of the protocol\ninterface IUniswapV2Router {\n    /// @notice Given an input asset amount, returns the maximum output amount of the\n    /// other asset (accounting for fees) given reserves.\n    /// @param path Addresses of the pools used to get prices\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\n\n    function swapExactTokensForTokens(\n        uint256 swapAmount,\n        uint256 minExpected,\n        address[] calldata path,\n        address receiver,\n        uint256 swapDeadline\n    ) external;\n}\n"
    },
    "contracts/interfaces/IVaultManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./ITreasury.sol\";\n\n// ========================= Key Structs and Enums =============================\n\n/// @notice Data to track during a series of action the amount to give or receive in stablecoins and collateral\n/// to the caller or associated addresses\nstruct PaymentData {\n    // Stablecoin amount the contract should give\n    uint256 stablecoinAmountToGive;\n    // Stablecoin amount owed to the contract\n    uint256 stablecoinAmountToReceive;\n    // Collateral amount the contract should give\n    uint256 collateralAmountToGive;\n    // Collateral amount owed to the contract\n    uint256 collateralAmountToReceive;\n}\n\n/// @notice Data stored to track someone's loan (or equivalently called position)\nstruct Vault {\n    // Amount of collateral deposited in the vault\n    uint256 collateralAmount;\n    // Normalized value of the debt (that is to say of the stablecoins borrowed)\n    uint256 normalizedDebt;\n}\n\n/// @notice Actions possible when composing calls to the different entry functions proposed\nenum ActionBorrowType {\n    createVault,\n    closeVault,\n    addCollateral,\n    removeCollateral,\n    repayDebt,\n    borrow,\n    getDebtIn,\n    permit\n}\n\n// ========================= Interfaces =============================\n\n/// @title IVaultManagerFunctions\n/// @author Angle Core Team\n/// @notice Interface for the `VaultManager` contract\n/// @dev This interface only contains functions of the contract which are called by other contracts\n/// of this module (without getters)\ninterface IVaultManagerFunctions {\n    /// @notice Allows composability between calls to the different entry points of this module. Any user calling\n    /// this function can perform any of the allowed actions in the order of their choice\n    /// @param actions Set of actions to perform\n    /// @param datas Data to be decoded for each action: it can include like the `vaultID` or the\n    /// @param from Address from which stablecoins will be taken if one action includes burning stablecoins. This address\n    /// should either be the `msg.sender` or be approved by the latter\n    /// @param to Address to which stablecoins and/or collateral will be sent in case of\n    /// @return paymentData Struct containing the final transfers executed\n    /// @dev This function is optimized to reduce gas cost due to payment from or to the user and that expensive calls\n    /// or computations (like `oracleValue`) are done only once\n    function angle(\n        ActionBorrowType[] memory actions,\n        bytes[] memory datas,\n        address from,\n        address to\n    ) external payable returns (PaymentData memory paymentData);\n\n    /// @notice Allows composability between calls to the different entry points of this module. Any user calling\n    /// this function can perform any of the allowed actions in the order of their choice\n    /// @param actions Set of actions to perform\n    /// @param datas Data to be decoded for each action: it can include like the `vaultID` or the\n    /// @param from Address from which stablecoins will be taken if one action includes burning stablecoins. This address\n    /// should either be the `msg.sender` or be approved by the latter\n    /// @param to Address to which stablecoins and/or collateral will be sent in case of\n    /// @param who Address of the contract to handle in case of repayment of stablecoins from received collateral\n    /// @param repayData Data to pass to the repayment contract in case of\n    /// @return paymentData Struct containing the final transfers executed\n    /// @dev This function is optimized to reduce gas cost due to payment from or to the user and that expensive calls\n    /// or computations (like `oracleValue`) are done only once\n    function angle(\n        ActionBorrowType[] memory actions,\n        bytes[] memory datas,\n        address from,\n        address to,\n        address who,\n        bytes memory repayData\n    ) external payable returns (PaymentData memory paymentData);\n\n    /// @notice Checks whether a given address is approved for a vault or owns this vault\n    /// @param spender Address for which vault ownership should be checked\n    /// @param vaultID ID of the vault to check\n    /// @return Whether the `spender` address owns or is approved for `vaultID`\n    function isApprovedOrOwner(address spender, uint256 vaultID) external view returns (bool);\n\n    /// @notice Allows an address to give or revoke approval for all its vaults to another address\n    /// @param owner Address signing the permit and giving (or revoking) its approval for all the controlled vaults\n    /// @param spender Address to give approval to\n    /// @param approved Whether to give or revoke the approval\n    /// @param deadline Deadline parameter for the signature to be valid\n    /// @dev The `v`, `r`, and `s` parameters are used as signature data\n    function permit(\n        address owner,\n        address spender,\n        bool approved,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\n/// @title IVaultManagerStorage\n/// @author Angle Core Team\n/// @notice Interface for the `VaultManager` contract\n/// @dev This interface contains getters of the contract's public variables used by other contracts\n/// of this module\ninterface IVaultManagerStorage {\n    /// @notice Reference to the `treasury` contract handling this `VaultManager`\n    function treasury() external view returns (ITreasury);\n\n    /// @notice Reference to the collateral handled by this `VaultManager`\n    function collateral() external view returns (IERC20);\n\n    /// @notice ID of the last vault created. The `vaultIDCount` variables serves as a counter to generate a unique\n    /// `vaultID` for each vault: it is like `tokenID` in basic ERC721 contracts\n    function vaultIDCount() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/external/lido/ISteth.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IStETH is IERC20 {\n    event Submitted(address sender, uint256 amount, address referral);\n\n    function submit(address) external payable returns (uint256);\n\n    function getSharesByPooledEth(uint256 _ethAmount) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/external/lido/IWStETH.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title IWStETH\n/// @author Angle Core Team\n/// @notice Interface for the `WStETH` contract\n/// @dev This interface only contains functions of the `WStETH` which are called by other contracts\n/// of this module\ninterface IWStETH is IERC20 {\n    function stETH() external returns (address);\n\n    function wrap(uint256 _stETHAmount) external returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/interfaces/IPoolManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"./IFeeManager.sol\";\nimport \"./IPerpetualManager.sol\";\nimport \"./IOracle.sol\";\n\n// Struct for the parameters associated to a strategy interacting with a collateral `PoolManager`\n// contract\nstruct StrategyParams {\n    // Timestamp of last report made by this strategy\n    // It is also used to check if a strategy has been initialized\n    uint256 lastReport;\n    // Total amount the strategy is expected to have\n    uint256 totalStrategyDebt;\n    // The share of the total assets in the `PoolManager` contract that the `strategy` can access to.\n    uint256 debtRatio;\n}\n\n/// @title IPoolManagerFunctions\n/// @author Angle Core Team\n/// @notice Interface for the collateral poolManager contracts handling each one type of collateral for\n/// a given stablecoin\n/// @dev Only the functions used in other contracts of the protocol are left here\ninterface IPoolManagerFunctions {\n    // ============================ Constructor ====================================\n\n    function deployCollateral(\n        address[] memory governorList,\n        address guardian,\n        IPerpetualManager _perpetualManager,\n        IFeeManager feeManager,\n        IOracle oracle\n    ) external;\n\n    // ============================ Yield Farming ==================================\n\n    function creditAvailable() external view returns (uint256);\n\n    function debtOutstanding() external view returns (uint256);\n\n    function report(\n        uint256 _gain,\n        uint256 _loss,\n        uint256 _debtPayment\n    ) external;\n\n    // ============================ Governance =====================================\n\n    function addGovernor(address _governor) external;\n\n    function removeGovernor(address _governor) external;\n\n    function setGuardian(address _guardian, address guardian) external;\n\n    function revokeGuardian(address guardian) external;\n\n    function setFeeManager(IFeeManager _feeManager) external;\n\n    // ============================= Getters =======================================\n\n    function getBalance() external view returns (uint256);\n\n    function getTotalAsset() external view returns (uint256);\n}\n\n/// @title IPoolManager\n/// @author Angle Core Team\n/// @notice Previous interface with additionnal getters for public variables and mappings\n/// @dev Used in other contracts of the protocol\ninterface IPoolManager is IPoolManagerFunctions {\n    function stableMaster() external view returns (address);\n\n    function perpetualManager() external view returns (address);\n\n    function token() external view returns (address);\n\n    function feeManager() external view returns (address);\n\n    function totalDebt() external view returns (uint256);\n\n    function strategies(address _strategy) external view returns (StrategyParams memory);\n}\n"
    },
    "contracts/interfaces/IOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\n/// @title IOracle\n/// @author Angle Core Team\n/// @notice Interface for Angle's oracle contracts reading oracle rates from both UniswapV3 and Chainlink\n/// from just UniswapV3 or from just Chainlink\ninterface IOracle {\n    function read() external view returns (uint256);\n\n    function readAll() external view returns (uint256 lowerRate, uint256 upperRate);\n\n    function readLower() external view returns (uint256);\n\n    function readUpper() external view returns (uint256);\n\n    function readQuote(uint256 baseAmount) external view returns (uint256);\n\n    function readQuoteLower(uint256 baseAmount) external view returns (uint256);\n\n    function inBase() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IPerpetualManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"./IERC721.sol\";\nimport \"./IFeeManager.sol\";\nimport \"./IOracle.sol\";\nimport \"./IAccessControl.sol\";\n\n/// @title Interface of the contract managing perpetuals\n/// @author Angle Core Team\n/// @dev Front interface, meaning only user-facing functions\ninterface IPerpetualManagerFront is IERC721Metadata {\n    function openPerpetual(\n        address owner,\n        uint256 amountBrought,\n        uint256 amountCommitted,\n        uint256 maxOracleRate,\n        uint256 minNetMargin\n    ) external returns (uint256 perpetualID);\n\n    function closePerpetual(\n        uint256 perpetualID,\n        address to,\n        uint256 minCashOutAmount\n    ) external;\n\n    function addToPerpetual(uint256 perpetualID, uint256 amount) external;\n\n    function removeFromPerpetual(\n        uint256 perpetualID,\n        uint256 amount,\n        address to\n    ) external;\n\n    function liquidatePerpetuals(uint256[] memory perpetualIDs) external;\n\n    function forceClosePerpetuals(uint256[] memory perpetualIDs) external;\n\n    // ========================= External View Functions =============================\n\n    function getCashOutAmount(uint256 perpetualID, uint256 rate) external view returns (uint256, uint256);\n\n    function isApprovedOrOwner(address spender, uint256 perpetualID) external view returns (bool);\n}\n\n/// @title Interface of the contract managing perpetuals\n/// @author Angle Core Team\n/// @dev This interface does not contain user facing functions, it just has functions that are\n/// interacted with in other parts of the protocol\ninterface IPerpetualManagerFunctions is IAccessControl {\n    // ================================= Governance ================================\n\n    function deployCollateral(\n        address[] memory governorList,\n        address guardian,\n        IFeeManager feeManager,\n        IOracle oracle_\n    ) external;\n\n    function setFeeManager(IFeeManager feeManager_) external;\n\n    function setHAFees(\n        uint64[] memory _xHAFees,\n        uint64[] memory _yHAFees,\n        uint8 deposit\n    ) external;\n\n    function setTargetAndLimitHAHedge(uint64 _targetHAHedge, uint64 _limitHAHedge) external;\n\n    function setKeeperFeesLiquidationRatio(uint64 _keeperFeesLiquidationRatio) external;\n\n    function setKeeperFeesCap(uint256 _keeperFeesLiquidationCap, uint256 _keeperFeesClosingCap) external;\n\n    function setKeeperFeesClosing(uint64[] memory _xKeeperFeesClosing, uint64[] memory _yKeeperFeesClosing) external;\n\n    function setLockTime(uint64 _lockTime) external;\n\n    function setBoundsPerpetual(uint64 _maxLeverage, uint64 _maintenanceMargin) external;\n\n    function pause() external;\n\n    function unpause() external;\n\n    // ==================================== Keepers ================================\n\n    function setFeeKeeper(uint64 feeDeposit, uint64 feesWithdraw) external;\n\n    // =============================== StableMaster ================================\n\n    function setOracle(IOracle _oracle) external;\n}\n\n/// @title IPerpetualManager\n/// @author Angle Core Team\n/// @notice Previous interface with additionnal getters for public variables\ninterface IPerpetualManager is IPerpetualManagerFunctions {\n    function poolManager() external view returns (address);\n\n    function oracle() external view returns (address);\n\n    function targetHAHedge() external view returns (uint64);\n\n    function totalHedgeAmount() external view returns (uint256);\n}\n\n/// @title Interface of the contract managing perpetuals with claim function\n/// @author Angle Core Team\n/// @dev Front interface with rewards function, meaning only user-facing functions\ninterface IPerpetualManagerFrontWithClaim is IPerpetualManagerFront, IPerpetualManager {\n    function getReward(uint256 perpetualID) external;\n}\n"
    },
    "contracts/interfaces/IFeeManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"./IAccessControl.sol\";\n\n/// @title IFeeManagerFunctions\n/// @author Angle Core Team\n/// @dev Interface for the `FeeManager` contract\ninterface IFeeManagerFunctions is IAccessControl {\n    // ================================= Keepers ===================================\n\n    function updateUsersSLP() external;\n\n    function updateHA() external;\n\n    // ================================= Governance ================================\n\n    function deployCollateral(\n        address[] memory governorList,\n        address guardian,\n        address _perpetualManager\n    ) external;\n\n    function setFees(\n        uint256[] memory xArray,\n        uint64[] memory yArray,\n        uint8 typeChange\n    ) external;\n\n    function setHAFees(uint64 _haFeeDeposit, uint64 _haFeeWithdraw) external;\n}\n\n/// @title IFeeManager\n/// @author Angle Core Team\n/// @notice Previous interface with additionnal getters for public variables and mappings\n/// @dev We need these getters as they are used in other contracts of the protocol\ninterface IFeeManager is IFeeManagerFunctions {\n    function stableMaster() external view returns (address);\n\n    function perpetualManager() external view returns (address);\n}\n"
    },
    "contracts/interfaces/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\n/// @title IAccessControl\n/// @author Forked from OpenZeppelin\n/// @notice Interface for `AccessControl` contracts\ninterface IAccessControl {\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    function grantRole(bytes32 role, address account) external;\n\n    function revokeRole(bytes32 role, address account) external;\n\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\ninterface IERC721 is IERC165 {\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n\ninterface IERC721Metadata is IERC721 {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/ITreasury.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\n/// @title ITreasury\n/// @author Angle Core Team\n/// @notice Interface for the `Treasury` contract\n/// @dev This interface only contains functions of the `Treasury` which are called by other contracts\n/// of this module\ninterface ITreasury {\n    /// @notice Checks whether a given address has well been initialized in this contract\n    /// as a `VaultManager``\n    /// @param _vaultManager Address to check\n    /// @return Whether the address has been initialized or not\n    function isVaultManager(address _vaultManager) external view returns (bool);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 833
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}